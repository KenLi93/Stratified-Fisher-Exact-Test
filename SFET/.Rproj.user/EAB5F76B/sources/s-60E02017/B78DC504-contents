#!/bin/Rscript
library(simulator)
library(np)

## Generate a model for simulating datasets

make_draws <- function(n, tru_fct){
  x <- runif(n)
  
  ## define the true functions and relative labels
  if (tru_fct==1){
    lab <- paste("n = ",n,",","f(x) =2x",sep="")
  } else if (tru_fct==2){
    lab <- paste("n = ",n,",","f(x)=x*pi",sep="")
  } else if (tru_fct==3){
    lab <- paste("n = ",n,",","f(x)=2x+x^3-6x^4",sep="")
  } else {
    lab <- paste("n = ",n,",","f(x)=sin(100*x)",sep="")
  }
  fx <- 2*x*(tru_fct==1) + sin(x*pi)*(tru_fct==2) +
    (2*x+x^3-6*x^4)*(tru_fct==3) + sin(100*x)*(tru_fct==4)
  
  
  new_model(name = "hw1p2", label = lab,
            params = list(n = n, x = x, tru_fct = tru_fct, fx=fx),
            simulate = function(n, x, tru_fct, fx, nsim){
                            y <- matrix(fx + rnorm(n*nsim),n,nsim)
              return(split(y, col(y)))
            })

}

## methods: linear regression, polynomial, Nadaraya-Watson "box", Nadaraya-Watxon "gaussian" 
lin_reg <- new_method("lin_reg", "Linear Regression",
                      method = function(model, draw){
                        lm.fit <- lm(draw ~ model$x)
                        list(yhat = predict(lm.fit))
                      })
## polynomial regression with degree 2-5
poly_2 <- new_method("poly_2", "Polynomial Regression (Deg: 2)",
                     method = function(model, draw){
                       poly2 <- lm(draw ~ poly(model$x, 2))
                       list(yhat = predict(poly2))
                     })

poly_3 <- new_method("poly_3", "Polynomial Regression (Deg: 3)",
                     method = function(model, draw){
                       poly3 <- lm(draw ~ poly(model$x, 3))
                       list(yhat = predict(poly3))
                     })

poly_4 <- new_method("poly_4", "Polynomial Regression (Deg: 4)",
                     method = function(model, draw){
                       poly4 <- lm(draw ~ poly(model$x, 4))
                       list(yhat = predict(poly4))
                     })

poly_5 <- new_method("poly_5", "Polynomial Regression (Deg: 5)",
                     method = function(model, draw){
                       poly5 <- lm(draw ~ poly(model$x, 5))
                       list(yhat = predict(poly5))
                     })

## kernal estimator with box or gaussian kernal functions
## bandwidth choose to be n^(-1/3) -- assymptotically optimal bandwidth
nw_box <- new_method("nw_box", "Nadaraya-Waston, box kernel",
                     method = function(model, draw, bandwidth){
                        ## leave-one-out cross validation
                       bw <- npregbw(draw ~ model$x, regtype = "lc", 
                                    bwmethod = "cv.ls", ckertype = "uniform")
                       list(yhat = predict(npreg(bw)))
                       
                     })

nw_gaussian <- new_method("nw_gaussian", "Nadaraya-Waston, gaussian kernel",
                     method = function(model, draw){
                        bw <- npregbw(draw ~ model$x, regtype = "lc", 
                                    bwmethod = "cv.ls", ckertype = "gaussian")
                       list(yhat = predict(npreg(bw)))
                     })

## metrics for evaluate the models: MSE
mse <- new_metric("mse", "MSE", 
                  metric = function(model, out){
                    mean((out$yhat - model$fx)^2)
                  })
## get sample size
n_obs <- new_metric("n_obs", "Number of observations",
                    metric = function(model, out){
                      model$n
                    })



sim <- new_simulation("hw1pb2", "Comparison of kernal estimators") %>%
  generate_model(make_draws, n = as.list(c(20,50,100,1000)), tru_fct = as.list(1:4),
                 vary_along = c("n", "tru_fct")) %>%
  simulate_from_model(nsim = 125, index = 1:4, parallel = list(socket_names = 4)) %>%
  run_method(list(lin_reg, poly_2, poly_3, poly_4, poly_5, nw_box, nw_gaussian),
             parallel = list(socket_names = 4, libraries = "np")) %>%
  evaluate(list(mse,n_obs))

save(sim,file = "sim_obj.RData")

jpeg("sim_f1.jpg")
subset_simulation(sim, tru_fct ==1 ) %>% 
  plot_eval_by("mse", varying = "n", method_col = c(1:6,"brown"),
               use_ggplot2 = F,
               main = expression(paste("f(x)=2x")),
               ylim = c(0,1))
dev.off()

jpeg("sim_f2.jpg")
subset_simulation(sim, tru_fct ==2 ) %>% 
  plot_eval_by("mse", varying = "n", method_col = c(1:6,"brown"),
               use_ggplot2 = F,
               main = expression(paste("f(x)=sin(x*", pi, ")", sep="")),
               ylim = c(0,1))
dev.off()

jpeg("sim_f3.jpg")
subset_simulation(sim, tru_fct ==3 ) %>% 
  plot_eval_by("mse", varying = "n", method_col = c(1:6,"brown"),
               use_ggplot2 = F,
               main = expression(paste("f(x)=","2x+", x^3,"-","6",x^4, sep="")),
               ylim = c(0,1))
dev.off()

jpeg("sim_f4.jpg")
subset_simulation(sim, tru_fct ==4 ) %>% 
  plot_eval_by("mse", varying = "n", method_col = c(1:6,"brown"),
               use_ggplot2 = F,
               main = expression(paste("f(x)=sin(100x)", sep="")),
               ylim = c(0,1))
dev.off()
